module maquina_estados(
    input wire clk,           // Reloj
    input wire reset,         // Señal de reset
    input wire test,          // Señal para cambiar de estado
    input wire [2:0] hambre,  // Nivel de hambre (0-5)
    input wire [2:0] diversion, // Nivel de diversión (0-5)
    input wire ultrasonido,   // Sensor de ultrasonido (<10 cm: 1 bit)
    input wire ruido,         // Sensor de ruido (1 bit)
    output reg [2:0] estado   // Salida del estado actual
);

// Definición de los estados
localparam NEUTRO     = 3'b000,
           FELIZ      = 3'b001,
           TRISTE     = 3'b010,
           CANSADO    = 3'b011,
           HAMBRIENTO = 3'b100,
           MUERTO     = 3'b101;

// Variables internas
reg [2:0] estado_actual, estado_siguiente;
reg test_anterior;  // Para detectar el flanco del botón 'test'

// Logica secuencial: Actualización de estado
always @(posedge clk or posedge reset) begin
    if (reset) begin
        estado_actual <= NEUTRO;  // Estado inicial en reset
        test_anterior <= 0;
    end else begin
        // Detectar flanco de test para cambiar el estado
        if (test && !test_anterior) begin
            estado_actual <= estado_siguiente;  // Cambiar estado
        end
        test_anterior <= test;
    end
end

// Lógica combinacional: Definir el estado siguiente basado en las entradas
always @(*) begin
    // Estado por defecto
    estado_siguiente = estado_actual;

    // Prioridad para cambiar de estado según la tabla
    if (hambre == 3'b101 || (hambre == 3'b000 && diversion == 3'b000)) begin
        estado_siguiente = MUERTO;
    end else if (ruido) begin
        estado_siguiente = CANSADO;
    end else if (hambre >= 3'b100) begin
        estado_siguiente = HAMBRIENTO;
    end else if (hambre <= 3'b010 && diversion >= 3'b100 && !ultrasonido && !ruido) begin
        estado_siguiente = FELIZ;
    end else if (hambre <= 3'b001 && diversion <= 3'b001 && ultrasonido && !ruido) begin
        estado_siguiente = TRISTE;
    end else if (hambre >= 3'b010 && hambre <= 3'b011 && diversion >= 3'b010 && diversion <= 3'b011 && !ultrasonido && !ruido) begin
        estado_siguiente = NEUTRO;
    end
end

// Asignación de la salida del estado actual
always @(*) begin
    estado = estado_actual;
end

endmodule
