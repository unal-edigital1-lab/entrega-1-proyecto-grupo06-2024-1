module fms_estado (
    input wire clk,          // Reloj para la máquina de estados
    input wire reset,        // Señal de reset que lleva al estado Neutro
    input wire test,         // Botón para cambiar de estado manualmente
    input wire [2:0] hambre, // Nivel de hambre (0-5)
    input wire [2:0] diversion, // Nivel de diversión (0-5)
    output reg [2:0] estado  // Salida que indica el estado actual (codificado)
);

// Definimos los estados
localparam FELIZ = 3'd0, TRISTE = 3'd1, CANSADO = 3'd2,
           HAMBRIENTO = 3'd3, NEUTRO = 3'd4, MUERTO = 3'd5;

// Estado y próximo estado
reg [2:0] estado_actual, estado_proximo;
reg test_prev; // Variable para detectar flanco ascendente del botón test

// Logica secuencial: Actualizar el estado en cada ciclo de reloj
always @(posedge clk or posedge reset) begin
    if (reset) begin
        estado_actual <= NEUTRO;  // Si se presiona reset, va al estado Neutro
    end else begin
        estado_actual <= estado_proximo;  // Cambia al próximo estado
    end
end

// Lógica combinacional: Decisión del próximo estado
always @(*) begin
    // Por defecto el próximo estado es el estado actual
    estado_proximo = estado_actual;

    // Navegación manual entre estados con el botón `test`
    if (test && !test_prev) begin
        case (estado_actual)
            FELIZ: estado_proximo = TRISTE;
            TRISTE: estado_proximo = CANSADO;
            CANSADO: estado_proximo = HAMBRIENTO;
            HAMBRIENTO: estado_proximo = MUERTO;
            MUERTO: estado_proximo = NEUTRO;
            NEUTRO: estado_proximo = FELIZ;
            default: estado_proximo = NEUTRO;  // Estado por defecto
        endcase
    end else begin
        // Lógica automática para cambiar el estado según las entradas
        if (hambre == 5) begin
            estado_proximo = MUERTO;  // Muerto por hambre máxima
        end else if (hambre >= 4) begin
            estado_proximo = HAMBRIENTO;  // Hambriento si el hambre es alta
        end else if (diversion <= 1 && hambre <= 1) begin
            estado_proximo = TRISTE;  // Triste por diversión baja y hambre baja
        end else if (diversion >= 4 && hambre <= 2) begin
            estado_proximo = FELIZ;  // Feliz si la diversión es alta y hambre baja
        end else if (diversion >= 2 && hambre >= 2) begin
            estado_proximo = NEUTRO;  // Neutro si hambre y diversión están en niveles medios
        end else begin
            estado_proximo = CANSADO;  // Si no se cumple ninguna otra condición, Cansado
        end
    end
end

// Guardar el estado anterior del botón test para detectar flanco ascendente
always @(posedge clk or posedge reset) begin
    if (reset) begin
        test_prev <= 0;
    end else begin
        test_prev <= test;
    end
end

// Salida: Estado actual
always @(posedge clk) begin
    estado <= estado_actual;
end

endmodule
